{
    "version": "https://jsonfeed.org/version/1",
    "title": "技术笔记",
    "subtitle": "幸好有你雯",
    "icon": "https://fallingkids.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://fallingkids.github.io",
    "items": [
        {
            "id": "https://fallingkids.github.io/mysql-note-04/",
            "url": "https://fallingkids.github.io/mysql-note-04/",
            "title": "一周浅谈：InnoDB数据页结构",
            "date_published": "2022-06-19T13:57:26.000Z",
            "content_html": "<h2 id=\"不同类型的页\"><a href=\"#不同类型的页\" class=\"headerlink\" title=\"不同类型的页\"></a>不同类型的页</h2><p>页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。InnoDB为了不同的目的而设计了多种不同类型的页，比如：</p>\n<ol>\n<li>存放表空间头部信息的页</li>\n<li>存放Change Buffer信息的页</li>\n<li>存放INODE信息的页</li>\n<li>存放undo日志信息的页</li>\n</ol>\n<p>这次我们关心的是那些存放表中记录的那种类型的页，官方称这种存放记录的页为索引（INDEX）页。鉴于我们还没有介绍过索引是什么，而这些表中的记录就是我平时所说的数据，所以我暂时把将这种存放记录的页称为数据页</p>\n<hr>\n<h2 id=\"数据页结构\"><a href=\"#数据页结构\" class=\"headerlink\" title=\"数据页结构\"></a>数据页结构</h2><p>数据页代表这块16KB大小的存储空间可以划分为多个部分，不同部分有不同含义，如下啊图所示：<br><img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1655654488/blog/mysql/mysql-note-04/5-1_qmjrcb.png\" alt=\"InnoDB数据页结构示意图.drawio.png\"><br>图5-1 InnoDB数据页结构示意图<br>表5-1 InnoDB数据页结构</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>中文名</th>\n<th>占用空间</th>\n<th>简答描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Header</td>\n<td>文件头部</td>\n<td>38字节</td>\n<td>页的一些通用信息</td>\n</tr>\n<tr>\n<td>Page Header</td>\n<td>页面头部</td>\n<td>56字节</td>\n<td>数据页专有的一些信息</td>\n</tr>\n<tr>\n<td>Infimum + Supremum</td>\n<td>页面中的最小记录和最大记录</td>\n<td>26字节</td>\n<td>两个虚拟的记录</td>\n</tr>\n<tr>\n<td>User Records</td>\n<td>用户记录</td>\n<td>不确定</td>\n<td>用户存储的记录内容</td>\n</tr>\n<tr>\n<td>Free Space</td>\n<td>空闲空间</td>\n<td>不确定</td>\n<td>页中尚未使用的空间</td>\n</tr>\n<tr>\n<td>Page Directory</td>\n<td>页目录</td>\n<td>不确定</td>\n<td>页中某些记录的相对位置</td>\n</tr>\n<tr>\n<td>File Trailer</td>\n<td>文件尾部</td>\n<td>8字节</td>\n<td>校验页是否完整</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"记录在页中的存储\"><a href=\"#记录在页中的存储\" class=\"headerlink\" title=\"记录在页中的存储\"></a>记录在页中的存储</h2><p>我们自己存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，没有User Records部分，每当插入一条记录时，都会从Free Space部分（也就是尚未使用的空间）申请一个记录大小的空间，并将这个空间划分到User Records部分。当Free Space部分的空间全部用完了，这也就意味着这个页使用完了，如果还有新的记录插入，就要去申请新的页了<br>那么接下来我们看下如何更好的管理User Records中的这些记录，这时候，我们就从记录行格式的记录头信息说起。</p>\n<h3 id=\"记录头信息\"><a href=\"#记录头信息\" class=\"headerlink\" title=\"记录头信息\"></a>记录头信息</h3><p>以下举一个例，我们先创建一个表：</p>\n<pre><code class=\"shell\">mysql&gt; CREATE TABLE page_demo(\n    -&gt;         c1 INT,\n    -&gt;         c2 INT,\n    -&gt;         c3 VARCHAR(10000),\n    -&gt;         PRIMARY KEY (c1)\n    -&gt;) CHARSET=ascii ROW_FORMAT=COMPACT;\n    Query OK, 0 rows affected (0.03 sec)\n</code></pre>\n<pre><code> 值得注意的是，我们把c1列指定为主键，所以InnoDB就没有必要创建row_id隐藏列了。而且我们为这个表指定了ascii字符集以及COMPACT的行格式，所以这个表中记录的行格式示意图如图所示：![COMPACT行格式示意图.drawio.png](https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1655655353/blog/mysql/mysql-note-04/5-3_iurcn6.png)\n</code></pre>\n<p>图5-3 COMPACT 行格式示意图<br>下面总结了一下每个字段属性的大体意思，如表5-2所示：<br>表5-2 记录头信息的属性及描述</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>大小（bit）</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>预留位1</td>\n<td>1</td>\n<td>没有使用</td>\n</tr>\n<tr>\n<td>预留位2</td>\n<td>1</td>\n<td>没有使用</td>\n</tr>\n<tr>\n<td>deleted_flag</td>\n<td>1</td>\n<td>标记该记录是否被删除</td>\n</tr>\n<tr>\n<td>min_rec_flag</td>\n<td>1</td>\n<td>B+树中每层非叶子节点中的最小的目录想记录都会添加该标记</td>\n</tr>\n<tr>\n<td>n_owned</td>\n<td>4</td>\n<td>一个页面中的记录会被分成若干个组，每个组中有一个记录是“带头大哥”，其余的记录都是“小弟”。“带头大哥”记录的n_owned值代表该组中所有的记录条数，“小弟”记录的n_owned值都为0</td>\n</tr>\n<tr>\n<td>heap_no</td>\n<td>13</td>\n<td>表示当记录在页面堆中的相对位置</td>\n</tr>\n<tr>\n<td>record_type</td>\n<td>3</td>\n<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点的目录项记录，2表示Infimum记录，3表示Supremum记录</td>\n</tr>\n<tr>\n<td>next_record</td>\n<td>16</td>\n<td>表示下一条记录的相对位置</td>\n</tr>\n</tbody></table>\n<pre><code>下面我们只在page_demo表的行格式演示图中（见图5-4）画出有关的头信息属性以及c1、c2、c3列的信息![page_demo表的行格式简化图.drawio.png](https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1655655406/blog/mysql/mysql-note-04/5-4_xuvckx.png)\n</code></pre>\n<p>下面向page_demo表中插入几条记录：</p>\n<pre><code class=\"shell\">mysql&gt; INSERT INTO page_demo VALUES(1, 100, &#39;aaaa&#39;), (2, 200, &#39;bbbb&#39;), (3, 300, &#39;cccc&#39;), \n(4, 400, &#39;dddd&#39;);\nQuery OK, 4 rows affected (0.00 sec)\nRecords: 4    Duplicates: 0    Warnings: 0\n</code></pre>\n<p>为了方便我们分析这些记录在页的User Records部分是这么表示的，这里爸记录中的头信息和实际的列数据都用十进制表示出来了（实际上是二进制）。这些记录的示意图如图5-5所示：<img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1655655442/blog/mysql/mysql-note-04/5-5_pbznvd.png\" alt=\"图5-5.drawio.png\"><br>图5-5 记录在页的User Records部分的存储结构</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "https://fallingkids.github.io/mysql-note-03/",
            "url": "https://fallingkids.github.io/mysql-note-03/",
            "title": "一周浅谈：InnoDB记录存储结构",
            "date_published": "2022-06-05T14:51:18.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前的文章，mysql对于我们来说还只是一个“黑盒”，我们只负责使用客户端发送请求，并且等待服务器返回结果。但是我们现在需要去搞清楚三个问题：</p>\n<ul>\n<li>表中的数据存到哪里（where）</li>\n<li>存放格式（what）</li>\n<li>mysql以书面方式来访问数据（how）</li>\n</ul>\n<p>接下来，我就重点总结一下mysql默认的存储引擎InnoDB，其他存储引擎的设计思路也大差不差，只不过特性不同罢了，设计思路差不多</p>\n<hr>\n<h2 id=\"InnoDB页简介\"><a href=\"#InnoDB页简介\" class=\"headerlink\" title=\"InnoDB页简介\"></a>InnoDB页简介</h2><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，即使我们关闭并且重启服务器，数据还是存在的。而真正处理数据的过程发生在内存中，所以是要把磁盘中的数据加载到内存中。如果是处理写入或修改请求，就还需要把内存中的内容刷新到磁盘上。</p>\n<hr>\n<h2 id=\"InnoDB行格式\"><a href=\"#InnoDB行格式\" class=\"headerlink\" title=\"InnoDB行格式\"></a>InnoDB行格式</h2><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘中的<strong>存放形式</strong>也被称为<strong>行格式或者记录格式</strong>。InnoDB的设计者设计了4中不同类型的行格式：</p>\n<ul>\n<li>COMPACT</li>\n<li>REDUNDANT</li>\n<li>DYNAMIC</li>\n<li>COMPRESSED<h3 id=\"指定行格式的语法\"><a href=\"#指定行格式的语法\" class=\"headerlink\" title=\"指定行格式的语法\"></a>指定行格式的语法</h3>可以在<strong>创建</strong>或者<strong>修改</strong>表的语句中指定记录所使用的的行格式：<pre><code>CREATE TABLE 表名 （列的信息） ROW_FORMAT=行格式名称;\nALTER TABLE 表名 ROW_FORMAT=行格式名称;\n</code></pre>\n为了探究接下来各个行格式下的数据结构到底有啥不同，所以假设在test_db中创建一张表record_format_demo，同时指定它的行格式<pre><code>mysql&gt; CREATE TABLE record_format_demo (\n  -&gt;     c1 VARCHAR(10),\n  -&gt;         c2 VARCHAR(10) NOT NULL,\n  -&gt;         c3 CHAR(10),\n  -&gt;     c4 VARCHAR(10),\n  -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;\n  Query OK, 0 rows affected (0. 03 sec)\n</code></pre>\n这张表的行格式是COMPACT，林外，我们还显式指定了字符集为ascii（因为ascii字符集只包含空格、标点符号、数字、大小写字母和一些不可见字符，所以汉字不能存到这张表中）现在我向表中插入两条记录：<pre><code>mysql&gt; INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES (&#39;aaaa&#39;, &#39;bbb&#39;, &#39;cc&#39;, &#39;d&#39;), (&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);\nQuery ok, 2 rows affected (0.02 sec)\nRecords: 2 Duplicates: 0 Warnings: 0\n</code></pre>\n现在表中的记录是这个样子的：<br>```<br>mysql&gt; SELECT * FROM record_format_demo;</li>\n</ul>\n<p>+——+—–+——+——+<br>| c1   | c2  | c3   | c4   |<br>+——+—–+——+——+<br>| aaaa | bbb | cc   | d    |<br>| eeee | fff | NULL | NULL |<br>+——+—–+——+——+<br>2 rows in set (0.00 sec)</p>\n<pre><code>现在可以看看每个行格式下的存储结构到底有啥不同\n### COMPACT行格式\n![](https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654441308/blog/2022-06-05/mysql-not-03-img1_lzdbrr.jpg)\nCOMPACT行格式示意图\n\n1. 记录的额外信息\n\n这部分信息是服务器为了更好地管理记录而不得不额外添加的一些信息。这些额外信息分为3个部分，分别是变长字段长度列表、NULL值列表和记录头信息。\n\n   1. 变长字段长度列表\n\nmysql支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、各种TEXT类型、各种BLOB类型。这些数据类型的列称为变长字段。因为变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于吧mysql服务器高懵逼，所以总结来说这些变长字段占用的存储空间分为两部分：\n\n   - 真正的数据内容\n   - 该数据占用的字节数\n\n在COMPACT行格式中，所有变长字段的真实数据占用的字节数都存放在记录的开头位置，从而形成一个变长字段长度列表，各边长字段的真实数据占用的字节数按照列的顺序**逆序**存放。\n以record_format_demo表中第一条记录来举个例子，因为record_format_demo表中的c1、c2、c4列都是VARCHAR(10)类型的，也就是变长的数据类型所以，所以这3个列的值占用的存储空间按字节数都需要保存在记录开头处。看下第一条记录各变长字段内容的长度\n\n| 列名 | 存储内容 | 内容长度（十进制表示） | 内容长度（十六进制表示） |\n| --- | --- | --- | --- |\n| c1 | &#39;aaaa&#39; | 4 | 0x04 |\n| c2 | &#39;bbb&#39; | 3 | 0x03 |\n| c4 | &#39;d&#39; | 1 | 0x01 |\n\n因为这些长度值需要按照列的顺序逆序存放，所以最后变长字段长度列表的字节串用十六进制的表示的效果就是：\n01 03 04\n需要说明的是，这里各个字节之间实际上没有空格，只是为了更好理解罢了。\n把这个字节串组成的变长字段长度列表填入到**COMPACT行格式示意图**的效果如下图所示。\n![](https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654441308/blog/2022-06-05/mysql-note-03-img2_rpi0ux.jpg)\n第一条记录的存储格式由于第一条记录中c1、c2、c4列中的字符串都比较短，也就是说占用的字节数比较小（c1列的内容是&#39;aaaa&#39;，占用4字节；c2列内容&#39;bbb&#39;，占用3字节；c4列内容&#39;d&#39;，占用1字节），每个变长字段的内容占用的字节数用1字节就可以表示（也就是4、3、1这3个数字可以分别用字节0x04、0x03、0x01表示）。但是，如果变长字段的内容占用的字节数比较多，可能就需要用2字节来表示。至于用1字节还是2字节来表示变长字段的真实数据占用的字节数，InnoDB是有它的一套规则的。为了更好的表述清楚这个规则，我们引入W、M和L这几个符号，先分别看看这些符号的意思。\n\n      - 假设某个字符集中最多需要W字节来表示一个字符（也就执行SHOW CHARSET语句后结果中的Maxlen列）。比如utf8mb4字符集中的W就是4，utf8是3，gbk是2，ascii是1\n      - 对于变长类型VARCHAR(M)来说，这种类型表示能存储最多M个字符（注意是字符不是字节哦），所以这种类型能表示的字符串最多占用的字节数就是 M*W\n      - 假设该变长字段实际存储的字符串占用的字节数是L\n\n确定使用1字节还是2字节来表示一个变长字段的真实数据占用的字节数的规则就是这样：\n\n      - 如果 M*W &lt;= 255，那么使用1字节来表示真实数据占用的字节数\n      - 如果 M*W &gt; 255，则分为下面两种情况：\n         - 如果 L &lt;= 127，则用1字节来表示真实数据占用的字节数\n         - 如果 L &gt; 127，则用2字节来表示真实数据占用的字节数\n\n总结：如果该变长字段允许存储的最大字节数（M*W）超过255字节，并且真实数据占用的字节数（L）超过127字节，则使用2字节来表示真实数据占用的字节数，否则使用1字节。\n\n   2. NULL值列表\n\n一条记录中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以COMPACT行格式把一条记录中值为NULL的列统一管理起来，存储到NULL值列表中。处理过程如下：\n\n      1. 统计表中允许存储NULL的列有哪些\n\n主键列以及使用NOT NULL修饰的列都是不可以存储NULL值的，所以在统计的时候不会吧这些列算进去。比如表record_format_demo的3个列c1、c3、c4都允许存储NULL值，而c2列使用NOT NULL进行了修饰，不允许存储NULL值\n\n      2. 如果表中没有允许存储NULL的列，则NULL值列表也就不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列。二进制位表示的意义如下：\n         1. 二进制位的值为1时，代表该列的值为 NULL\n         1. 二进制位的值为0时，代表该列的值不为 NULL\n\n因为表 record_format_demo 有3个值允许为 NULL 的列，所以这3个列的二进制位的对应关系如下图所示。再次强调一次，二进制位按照列的顺序逆序排序，所以第一个列c1和最后一个二进制位对应\n![](https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655022398588-408bbae8-2182-4e27-a997-0cbec694a0cd.jpeg)\n\n   3. MySQL规定 NULL 值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，所以在字节的高位补0，效果图如下\n\n![](https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655023378624-1c17e277-1c86-4c21-92c9-8f2847465606.jpeg)\n以此类推，如果一个表中有9个值允许为 NULL 的列，则这个记录的 NULL 值列表部分就需要2字节来表示了。\n知道了规则以后，我们再返回头看看表 record_format_demo 中两条记录中的  NULL 值列表应该怎么存储。因为只有c1、c3、c4这3个列的值都允许存储 NULL 值，所以记录的 NULL 值列表处只需要一个字节\n\n      - 对于第一条记录来说，c1、c3、c4这3个列的值都不为 NULL，所以它们对应的二进制位都是0，如下图所示\n\n![](https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655025036533-5154c9d5-c725-4f38-b801-711c6d9d12d8.jpeg)\n所以第一条记录的 NULL 值列表用十六进制表示就是0x00\n\n      - 对于第二条记录来说，c1、c3、c4这3个列中c3和c4的值都为 NULL，所以这3个列对应的二进制位的情况如下图所示\n\n![](https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655025036533-5154c9d5-c725-4f38-b801-711c6d9d12d8.jpeg)\n所以第二条记录的 NULL 值列表用十六进制表示就是 0x06\n这两条记录在填充了 NULL 值列表后的示意图如下所示：\n![](https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655025577534-a5ec0d04-4fe2-4097-bbe8-f0593563dbe3.jpeg)\n\n   4. 记录头信息\n\n除了变长字段长度列表、NULL 值列表之外，还有一个称之为记录头信息的部分。记录头信息由固定的5字节组成，用于描述记录的一些属性。5字节也就是40个二进制位，不同的位代表不同的意思，如下图所示：\n![](https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655045826404-a53de900-ffc0-41e6-9351-b63a46d1e7ea.jpeg)\n这些二进制位代表的详情信息如表所示：\n**记录头信息中各二进制位代表的详细信息**\n\n| 名称 | 大小（位） | 描述 |\n| --- | --- | --- |\n| 预留位1 | 1 | 没有使用 |\n| 预留位2 | 1 | 没有使用 |\n| deleted_flag | 1 | 标记该记录是否被删除 |\n| min_rec_flag | 1 | B+树的每层非叶子节点中最小的项目项记录都会添加该标记 |\n| n_owned | 4 | 一个页面中的记录会被分成若干个组，每个组中有一个记录是“带头大哥”，其余的记录都是“小弟”。“带头大哥”记录n_owned  值都为0 |\n| heap_no | 13 | 表示当前记录在页面堆中的相对位置 |\n| record_type | 3 | 表示当前记录的类型，0表示普通记录，1表示B+树飞叶子节点的目录项记录，2表示Infimum记录，3表示Supremum记录 |\n| next_record | 16 | 表示下一条记录的相对位置 |\n\n2. 记录的真实数据\n\n对于 record_format_demo 表来说，记录的真实数据除了c1、c2、c3、c4这几个我们自己定义的列的数据外，MySQL会为每个记录默认地添加一些列（也称为隐藏列），具体的列如下表所示\n**MySQL为每个记录默认添加的列**\n\n| 列名 | 是否必需 | 占用空间 | 描述 |\n| --- | --- | --- | --- |\n| row_id | 否 | 6字节 | 行ID，唯一标识一条记录 |\n| trx_id | 是 | 6字节 | 事务ID |\n| roll_pointer | 是 | 7字节 | 回滚指针 |\n\n这里提一下InnoDB表的主键生成策略：优先使用用户自定义的主键作为主键；如果用户没有定义主键，则选取一个不允许存储 NULL 值的 UNIQUE 键作为主键：如果表中连不允许存储 NULL 值的 UNIQUE 键都没有定义，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键\n\n&gt; 这几个真正的列的真正名称是DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，但是后面的描述中都用小写描述\n\n3. \n\n\n---\n\n## 其他\n</code></pre>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "https://fallingkids.github.io/mysql-note-02/",
            "url": "https://fallingkids.github.io/mysql-note-02/",
            "title": "一周浅谈：Mysql - 字符集和比较规则",
            "date_published": "2022-06-01T14:56:49.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>计算机中实际存储的是二进制数据，是没有办法直接存储字符串的，因此为了存储字符是建立在字符与二进制数据的映射关系之上。建立这个关系，我们首先需要解决两个问题：</p>\n<ul>\n<li><p>要把哪些字符映射成二进制数据？</p>\n</li>\n<li><p>怎么映射？把字符映射成二进制数据叫做编码，将二进制数据映射到字符叫做解码</p>\n<pre><code>&#39;a&#39; -&gt; 00000001 (十六进制0x01)\n&#39;b&#39; -&gt; 00000010 (十六进制0x02)\n&#39;A&#39; -&gt; 00000011 (十六进制0x03)\n&#39;B&#39; -&gt; 00000100 (十六进制0x04)\n</code></pre>\n<p>现在有了我们自己的字符集，我们就可以用二进制表示一些字符串了，例如：</p>\n</li>\n<li><p>‘bA’ -&gt; 0000001000000011 （十六进制0x0203）</p>\n</li>\n<li><p>‘baB’ -&gt; 000000100000000100000100 （十六进制0x020104）</p>\n</li>\n<li><p>‘cd’ -&gt; 无法表示，因为huyizhou字符集里不包含’c’和’d’</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"字符比较规则\"><a href=\"#字符比较规则\" class=\"headerlink\" title=\"字符比较规则\"></a>字符比较规则</h2><p>其实字符的比较，最容易想到的就是比较两个字符对应的二进制编码大小。二进制比较规则景观很简单，但是有时候并不符合现实的需求。例如，在很多场景下，英文字符都是不区分大小写的，换句话说’a’和’A’是相等的，这个时候就不能简单的使用二进制比较，这个时候就需要这两个规则：</p>\n<ul>\n<li>将两个大小写不同的字符全部都转为大写或者小写</li>\n<li>再比较这两个字符对应的二进制数据</li>\n</ul>\n<hr>\n<h2 id=\"常见的字符集\"><a href=\"#常见的字符集\" class=\"headerlink\" title=\"常见的字符集\"></a>常见的字符集</h2><ul>\n<li><p>ASCII字符集：共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见的字符。由于ASCII字符集一共也才128个字符，所以可以使用一个字节来进行编码</p>\n<pre><code>&#39;L&#39; -&gt; 01001100 （十六进制0x4C，十进制76）\n&#39;M&#39; -&gt; 01001101 （十六进制0x4D，十进制77）\n</code></pre>\n</li>\n<li><p>ISO 8859-1 字符集：共收录256个字符，在ASCII字符集的基础上又扩充了128个西欧常用字符，因此ISO 8859-1字符集也可以使用一个字节来进行编码</p>\n</li>\n<li><p>GBK</p>\n</li>\n<li><p>UTF-8</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2></li>\n</ul>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "https://fallingkids.github.io/mysql-note-01/",
            "url": "https://fallingkids.github.io/mysql-note-01/",
            "title": "一周浅谈：Mysql整体架构设计",
            "date_published": "2022-06-01T02:50:55.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近刚开始再看《Mysql是怎样运行的 –从根儿上理解MySQL》，迫于见明的压力，在此开始写一些笔记也好或者对于该书获取的一些知识点提炼出来</p>\n<hr>\n<h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p><img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654054743/blog/2022-06-01/image_qvugqu.png\" alt=\"image.png\"></p>\n<ol>\n<li><p>建立连接</p>\n<p>就跟大部分的开源组件的模式一样，client和server。client具体为api，在不同的应用方进行调用；server具体实现业务如存储，查询，分词等一些逻辑。当然，client与server之间的连接是有通过我们熟悉的tcp连接，还有命名管道和共享内存，UNIX域套接字</p>\n</li>\n<li><p>解析与优化</p>\n</li>\n</ol>\n<p>mysql服务器从客户端那获得了文本形式的请求，接下来数据要从存储中取出来，还需要很多前置的过程，比如：要取什么数据（对于sql语句需要做出分析传递给下一层），怎么取是最快，这部分做这件事情</p>\n<ol start=\"3\">\n<li>存储引擎</li>\n</ol>\n<p>当服务完成了查询优化以后，都还没有真正地去访问真实的表中数据（在查询期间可能会访问表中少量的数据）。因此，mysql服务器把数据的存储和提取操作都封装到存储引擎模块（表处理器）中。从逻辑上，表示一行一行的记录组成。在物理上，如何表示记录，怎么读取记录，把数据写入具体的物理存储器，这些都存储引擎负责的事情。同时存储引擎是各种各样的，可以根据用户自己选择去使用，因此作为开发者的我们可以自己开发一套存储引擎去使用</p>\n<hr>\n<h2 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h2><ol>\n<li>TCP/IP</li>\n</ol>\n<p>在真实的环境中，数据库服务器进程和客户端进程可能会运行在不同的主机中，因此必须网络进行通讯。mysql服务器中默认的端口号是3306，默认监听3306端口。因此我们就可以通过IP地址+端口号的方式与这个进程建立连接，这样进程间就可以进行网络通讯。下面一些关于网络连接用到的指令</p>\n<pre><code>mysqld -P3307\n</code></pre>\n<pre><code>mysql -h127.0.0.1 -uroot -P3307 -p\n</code></pre>\n<ol start=\"2\">\n<li>命名管道和共享内存</li>\n</ol>\n<p>windows用户可以用这招，我就不细了解 </p>\n<ol start=\"3\">\n<li>UNIX域套接字</li>\n</ol>\n<p>服务器进程和客户端进程都运行在操作系统为类UNIX的同一台机器上，就可以使用这个方法进行进程间通讯。不细聊了</p>\n<hr>\n<h2 id=\"连接管理\"><a href=\"#连接管理\" class=\"headerlink\" title=\"连接管理\"></a>连接管理</h2><ul>\n<li>线程池</li>\n</ul>\n<p>当每有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程专门处理这个客户端的交互：当该客户端退出时会与服务器断开连接，服务器并不会直接把和客户端交互建立起来的线程销毁，而是把他缓存起来，当另一个新的客户端再进行连接时，把这个缓存的线程分配给新客户端。这样就避免了频繁创建和销毁线程，节省开销。mysql服务器是为每一个进来的客户端分配一个线程，这样的问题就会有，加入线程分配的太多就会严重影响系统性能，所以我们也需要限制可以同时连接到服务器的客户端数量，也就是我们日常口中经常提到的连接池，mysql也把这个字段开放出来，让我们来配置，因此这个配置的数值很考验开发者对我们的机器资源以及需要什么样的性能要有一个很深刻的理解。</p>\n<ul>\n<li>身份认证</li>\n</ul>\n<p>当客户端发起连接时，是会携带主机信息、用户名、密码等信息，服务器程序就会对客户端提供的这些信息进行认证。如果认证失败，服务器就会拒绝连接。同时，当客户端与服务器是部署在不同的地方，可以采用传输层安全性协议对连接进行加密</p>\n<h2 id=\"解析与优化\"><a href=\"#解析与优化\" class=\"headerlink\" title=\"解析与优化\"></a>解析与优化</h2><ol>\n<li>查询缓存（5.7.20以后不推荐使用，8.0中直接将其删除）</li>\n</ol>\n<p>我在平时开发的过程中，当缓存中没有数据时，一次数据获取都从调用BI的数据接口来获取。但是为了提高效率，会把刚刚查询的结果放入缓存中，这样在短时间内再查询一次就能提高查询的效率，不需要做过多的计算。mysql也是如此，但是mysql对于两个查询请求有任何字符上面的不同（例如，空格、注释、大小写），都会导致缓存不会命中。另外，查询中包含某些函数、用户自定义变量和函数、系统表，如mysql、information_schema、performance_schema数据库中的表，这个请求也不会命中。当然，缓存也会有缓存失效的时候，只要表的结构或者发生了更改或者数据发生了修改，对应的所有缓存表全部失效</p>\n<ol start=\"2\">\n<li>语法解析</li>\n</ol>\n<p>我们知道客户端程序发送过来的请求指示一段文本，mysql服务器首先要对这段文本进行分析。属于编译过程了，设计词法解析、语法解析、语义分析，不深聊了</p>\n<ol start=\"3\">\n<li><p>查询优化</p>\n<p>  语法解析之后，服务器已经获得了需要的信息（要查询的表和列是哪些、搜索条件是什么）。但是我们写的mysql语句执行起来效率可能并不是那么高，所以mysql的优化程序会对我们的语句做一些优化，优化结果就是生成一个执行计划（explain），这个执行计划表明了应该用哪些索引执行查询，以及表之间额查询顺序是啥，等等。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><p>mysql服务器把数据的存储和提取操作都封装到了一个名为存储引擎的模块中，mysql中有很多存储引擎，但是最常用的还是InnoDB，偶尔用一下MyISAM，再偶尔用一下MEMORY</p>\n<ul>\n<li>InnoDB</li>\n</ul>\n<p>支持事务、行级别、外键</p>\n<ul>\n<li>MyISAM</li>\n</ul>\n<p>主要的非事务处理存储引擎</p>\n<ul>\n<li>MEMORY</li>\n</ul>\n<p>数据只存储在内存，不存储在磁盘；多用于临时表</p>\n<hr>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>本来想写第二章的内容，启动选项和系统变量，但是发现感觉不是很有必要，后面有必要再补上</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "https://fallingkids.github.io/hello-world/",
            "url": "https://fallingkids.github.io/hello-world/",
            "title": "Hello World",
            "date_published": "2022-05-31T07:28:50.131Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}