{
    "version": "https://jsonfeed.org/version/1",
    "title": "技术笔记",
    "subtitle": "幸好有你雯",
    "icon": "https://fallingkids.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://fallingkids.github.io",
    "items": [
        {
            "id": "https://fallingkids.github.io/mysql-note-04/",
            "url": "https://fallingkids.github.io/mysql-note-04/",
            "title": "一周浅谈：InnoDB数据页结构",
            "date_published": "2022-06-19T13:57:26.000Z",
            "content_html": "<h2 id=\"不同类型的页\"><a class=\"anchor\" href=\"#不同类型的页\">#</a> 不同类型的页</h2>\n<p>页是 InnoDB 管理存储空间的基本单位，一个页的大小一般是 16KB。InnoDB 为了不同的目的而设计了多种不同类型的页，比如：</p>\n<ol>\n<li>存放表空间头部信息的页</li>\n<li>存放 Change Buffer 信息的页</li>\n<li>存放 INODE 信息的页</li>\n<li>存放 undo 日志信息的页</li>\n</ol>\n<p>这次我们关心的是那些存放表中记录的那种类型的页，官方称这种存放记录的页为索引（INDEX）页。鉴于我们还没有介绍过索引是什么，而这些表中的记录就是我平时所说的数据，所以我暂时把将这种存放记录的页称为数据页</p>\n<hr />\n<h2 id=\"数据页结构\"><a class=\"anchor\" href=\"#数据页结构\">#</a> 数据页结构</h2>\n<p>数据页代表这块 16KB 大小的存储空间可以划分为多个部分，不同部分有不同含义，如下啊图所示：<br />\n&lt;div align=center&gt;&lt;img src =&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZXMuY2xvdWRpbmFyeS5jb20vaHR0cHMtZmFsbGluZ2tpZHMtZ2l0aHViLWlvL2ltYWdlL3VwbG9hZC92MTY1NTY1NDQ4OC9ibG9nL215c3FsL215c3FsLW5vdGUtMDQvNS0xX3FtanJjYi5wbmc=\">https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1655654488/blog/mysql/mysql-note-04/5-1_qmjrcb.png</span>&quot;/&gt;&lt;/div&gt;</p>\n<p>&lt;center&gt; 图 5-1 InnoDB 数据页结构示意图 &lt;/center&gt;</p>\n<p>&lt;center&gt; 表 5-1 InnoDB 数据页结构 &lt;/center&gt;</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>中文名</th>\n<th>占用空间</th>\n<th>简答描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>File Header</td>\n<td>文件头部</td>\n<td>38 字节</td>\n<td>页的一些通用信息</td>\n</tr>\n<tr>\n<td>Page Header</td>\n<td>页面头部</td>\n<td>56 字节</td>\n<td>数据页专有的一些信息</td>\n</tr>\n<tr>\n<td>Infimum + Supremum</td>\n<td>页面中的最小记录和最大记录</td>\n<td>26 字节</td>\n<td>两个虚拟的记录</td>\n</tr>\n<tr>\n<td>User Records</td>\n<td>用户记录</td>\n<td>不确定</td>\n<td>用户存储的记录内容</td>\n</tr>\n<tr>\n<td>Free Space</td>\n<td>空闲空间</td>\n<td>不确定</td>\n<td>页中尚未使用的空间</td>\n</tr>\n<tr>\n<td>Page Directory</td>\n<td>页目录</td>\n<td>不确定</td>\n<td>页中某些记录的相对位置</td>\n</tr>\n<tr>\n<td>File Trailer</td>\n<td>文件尾部</td>\n<td>8 字节</td>\n<td>校验页是否完整</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h2 id=\"记录在页中的存储\"><a class=\"anchor\" href=\"#记录在页中的存储\">#</a> 记录在页中的存储</h2>\n<p>我们自己存储的记录会按照指定的行格式存储到 User Records 部分。但是在一开始生成页的时候，没有 User Records 部分，每当插入一条记录时，都会从 Free Space 部分（也就是尚未使用的空间）申请一个记录大小的空间，并将这个空间划分到 User Records 部分。当 Free Space 部分的空间全部用完了，这也就意味着这个页使用完了，如果还有新的记录插入，就要去申请新的页了<br />\n那么接下来我们看下如何更好的管理 User Records 中的这些记录，这时候，我们就从记录行格式的记录头信息说起。</p>\n<h3 id=\"记录头信息\"><a class=\"anchor\" href=\"#记录头信息\">#</a> 记录头信息</h3>\n<p>以下举一个例，我们先创建一个表：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mysql<span class=\"token operator\">></span> CREATE TABLE page_demo<span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    -<span class=\"token operator\">></span>\t\t c1 INT,</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    -<span class=\"token operator\">></span>\t\t c2 INT,</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    -<span class=\"token operator\">></span>\t\t c3 VARCHAR<span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span>,</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    -<span class=\"token operator\">></span>\t\t PRIMARY KEY <span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    -<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">CHARSET</span><span class=\"token operator\">=</span>ascii <span class=\"token assign-left variable\">ROW_FORMAT</span><span class=\"token operator\">=</span>COMPACT<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    Query OK, <span class=\"token number\">0</span> rows affected <span class=\"token punctuation\">(</span><span class=\"token number\">0.03</span> sec<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>值得注意的是，我们把 c1 列指定为主键，所以 InnoDB 就没有必要创建 row_id 隐藏列了。而且我们为这个表指定了 ascii 字符集以及 COMPACT 的行格式，所以这个表中记录的行格式示意图如图所示：<img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1655655353/blog/mysql/mysql-note-04/5-3_iurcn6.png\" alt=\"COMPACT行格式示意图.drawio.png\" /><br />\n&lt;center&gt; 图 5-3 COMPACT 行格式示意图 &lt;/center&gt;</p>\n<p>下面总结了一下每个字段属性的大体意思，如表 5-2 所示：<br />\n表 5-2 记录头信息的属性及描述</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>大小（bit）</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>预留位 1</td>\n<td>1</td>\n<td>没有使用</td>\n</tr>\n<tr>\n<td>预留位 2</td>\n<td>1</td>\n<td>没有使用</td>\n</tr>\n<tr>\n<td>deleted_flag</td>\n<td>1</td>\n<td>标记该记录是否被删除</td>\n</tr>\n<tr>\n<td>min_rec_flag</td>\n<td>1</td>\n<td>B + 树中每层非叶子节点中的最小的目录想记录都会添加该标记</td>\n</tr>\n<tr>\n<td>n_owned</td>\n<td>4</td>\n<td>一个页面中的记录会被分成若干个组，每个组中有一个记录是 “带头大哥”，其余的记录都是 “小弟”。“带头大哥” 记录的 n_owned 值代表该组中所有的记录条数，“小弟” 记录的 n_owned 值都为 0</td>\n</tr>\n<tr>\n<td>heap_no</td>\n<td>13</td>\n<td>表示当记录在页面堆中的相对位置</td>\n</tr>\n<tr>\n<td>record_type</td>\n<td>3</td>\n<td>表示当前记录的类型，0 表示普通记录，1 表示 B + 树非叶节点的目录项记录，2 表示 Infimum 记录，3 表示 Supremum 记录</td>\n</tr>\n<tr>\n<td>next_record</td>\n<td>16</td>\n<td>表示下一条记录的相对位置</td>\n</tr>\n</tbody>\n</table>\n<p>下面我们只在 page_demo 表的行格式演示图中（见图 5-4）画出有关的头信息属性以及 c1、c2、c3 列的信息<img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1655655406/blog/mysql/mysql-note-04/5-4_xuvckx.png\" alt=\"page_demo表的行格式简化图.drawio.png\" /></p>\n<p>下面向 page_demo 表中插入几条记录：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mysql<span class=\"token operator\">></span> INSERT INTO page_demo VALUES<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>, <span class=\"token number\">100</span>, <span class=\"token string\">'aaaa'</span><span class=\"token punctuation\">)</span>, <span class=\"token punctuation\">(</span><span class=\"token number\">2</span>, <span class=\"token number\">200</span>, <span class=\"token string\">'bbbb'</span><span class=\"token punctuation\">)</span>, <span class=\"token punctuation\">(</span><span class=\"token number\">3</span>, <span class=\"token number\">300</span>, <span class=\"token string\">'cccc'</span><span class=\"token punctuation\">)</span>, </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span><span class=\"token number\">4</span>, <span class=\"token number\">400</span>, <span class=\"token string\">'dddd'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Query OK, <span class=\"token number\">4</span> rows affected <span class=\"token punctuation\">(</span><span class=\"token number\">0.00</span> sec<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Records: <span class=\"token number\">4</span>\tDuplicates: <span class=\"token number\">0</span>\tWarnings: <span class=\"token number\">0</span></pre></td></tr></table></figure><p>为了方便我们分析这些记录在页的 User Records 部分是这么表示的，这里爸记录中的头信息和实际的列数据都用十进制表示出来了（实际上是二进制）。这些记录的示意图如图 5-5 所示：<img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1655655442/blog/mysql/mysql-note-04/5-5_pbznvd.png\" alt=\"图5-5.drawio.png\" /><br />\n&lt;center&gt; 图 5-5 记录在页的 User Records 部分的存储结构 &lt;/center&gt;</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "https://fallingkids.github.io/mysql-note-03/",
            "url": "https://fallingkids.github.io/mysql-note-03/",
            "title": "一周浅谈：InnoDB记录存储结构",
            "date_published": "2022-06-05T14:51:18.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>之前的文章，mysql 对于我们来说还只是一个 “黑盒”，我们只负责使用客户端发送请求，并且等待服务器返回结果。但是我们现在需要去搞清楚三个问题：</p>\n<ul>\n<li>表中的数据存到哪里（where）</li>\n<li>存放格式（what）</li>\n<li>mysql 以书面方式来访问数据（how）</li>\n</ul>\n<p>接下来，我就重点总结一下 mysql 默认的存储引擎 InnoDB，其他存储引擎的设计思路也大差不差，只不过特性不同罢了，设计思路差不多</p>\n<hr />\n<h2 id=\"innodb页简介\"><a class=\"anchor\" href=\"#innodb页简介\">#</a> InnoDB 页简介</h2>\n<p>InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，即使我们关闭并且重启服务器，数据还是存在的。而真正处理数据的过程发生在内存中，所以是要把磁盘中的数据加载到内存中。如果是处理写入或修改请求，就还需要把内存中的内容刷新到磁盘上。</p>\n<hr />\n<h2 id=\"innodb行格式\"><a class=\"anchor\" href=\"#innodb行格式\">#</a> InnoDB 行格式</h2>\n<p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘中的<strong>存放形式</strong>也被称为<strong>行格式或者记录格式</strong>。InnoDB 的设计者设计了 4 中不同类型的行格式：</p>\n<ul>\n<li>COMPACT</li>\n<li>REDUNDANT</li>\n<li>DYNAMIC</li>\n<li>COMPRESSED</li>\n</ul>\n<h3 id=\"指定行格式的语法\"><a class=\"anchor\" href=\"#指定行格式的语法\">#</a> 指定行格式的语法</h3>\n<p>可以在<strong>创建</strong>或者<strong>修改</strong>表的语句中指定记录所使用的的行格式：</p>\n<pre><code>CREATE TABLE 表名 （列的信息） ROW_FORMAT=行格式名称;\nALTER TABLE 表名 ROW_FORMAT=行格式名称;\n</code></pre>\n<p>为了探究接下来各个行格式下的数据结构到底有啥不同，所以假设在 test_db 中创建一张表 record_format_demo，同时指定它的行格式</p>\n<pre><code>mysql&gt; CREATE TABLE record_format_demo (\n    -&gt;     c1 VARCHAR(10),\n    -&gt;\t\t c2 VARCHAR(10) NOT NULL,\n    -&gt;\t\t c3 CHAR(10),\n    -&gt;     c4 VARCHAR(10),\n    -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;\n    Query OK, 0 rows affected (0. 03 sec)\n</code></pre>\n<p>这张表的行格式是 COMPACT，林外，我们还显式指定了字符集为 ascii（因为 ascii 字符集只包含空格、标点符号、数字、大小写字母和一些不可见字符，所以汉字不能存到这张表中）现在我向表中插入两条记录：</p>\n<pre><code>mysql&gt; INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES ('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);\nQuery ok, 2 rows affected (0.02 sec)\nRecords: 2 Duplicates: 0 Warnings: 0\n</code></pre>\n<p>现在表中的记录是这个样子的：</p>\n<pre><code>mysql&gt; SELECT * FROM record_format_demo;\n+------+-----+------+------+\n| c1   | c2  | c3   | c4   |\n+------+-----+------+------+\n| aaaa | bbb | cc   | d    |\n| eeee | fff | NULL | NULL |\n+------+-----+------+------+\n2 rows in set (0.00 sec)\n</code></pre>\n<p>现在可以看看每个行格式下的存储结构到底有啥不同</p>\n<h3 id=\"compact行格式\"><a class=\"anchor\" href=\"#compact行格式\">#</a> COMPACT 行格式</h3>\n<p><img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654441308/blog/2022-06-05/mysql-not-03-img1_lzdbrr.jpg\" alt=\"\" /><br />\nCOMPACT 行格式示意图</p>\n<ol>\n<li>记录的额外信息</li>\n</ol>\n<p>这部分信息是服务器为了更好地管理记录而不得不额外添加的一些信息。这些额外信息分为 3 个部分，分别是变长字段长度列表、NULL 值列表和记录头信息。</p>\n<ol>\n<li>变长字段长度列表</li>\n</ol>\n<p>mysql 支持一些变长的数据类型，比如 VARCHAR (M)、VARBINARY (M)、各种 TEXT 类型、各种 BLOB 类型。这些数据类型的列称为变长字段。因为变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于吧 mysql 服务器高懵逼，所以总结来说这些变长字段占用的存储空间分为两部分：</p>\n<ul>\n<li>真正的数据内容</li>\n<li>该数据占用的字节数</li>\n</ul>\n<p>在 COMPACT 行格式中，所有变长字段的真实数据占用的字节数都存放在记录的开头位置，从而形成一个变长字段长度列表，各边长字段的真实数据占用的字节数按照列的顺序<strong>逆序</strong>存放。<br />\n以 record_format_demo 表中第一条记录来举个例子，因为 record_format_demo 表中的 c1、c2、c4 列都是 VARCHAR (10) 类型的，也就是变长的数据类型所以，所以这 3 个列的值占用的存储空间按字节数都需要保存在记录开头处。看下第一条记录各变长字段内容的长度</p>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>存储内容</th>\n<th>内容长度（十进制表示）</th>\n<th>内容长度（十六进制表示）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c1</td>\n<td>'aaaa'</td>\n<td>4</td>\n<td>0x04</td>\n</tr>\n<tr>\n<td>c2</td>\n<td>'bbb'</td>\n<td>3</td>\n<td>0x03</td>\n</tr>\n<tr>\n<td>c4</td>\n<td>'d'</td>\n<td>1</td>\n<td>0x01</td>\n</tr>\n</tbody>\n</table>\n<p>因为这些长度值需要按照列的顺序逆序存放，所以最后变长字段长度列表的字节串用十六进制的表示的效果就是：<br />\n01 03 04<br />\n 需要说明的是，这里各个字节之间实际上没有空格，只是为了更好理解罢了。<br />\n把这个字节串组成的变长字段长度列表填入到<strong> COMPACT 行格式示意图</strong>的效果如下图所示。<br />\n<img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654441308/blog/2022-06-05/mysql-note-03-img2_rpi0ux.jpg\" alt=\"\" /><br />\n第一条记录的存储格式由于第一条记录中 c1、c2、c4 列中的字符串都比较短，也就是说占用的字节数比较小（c1 列的内容是 'aaaa'，占用 4 字节；c2 列内容 'bbb'，占用 3 字节；c4 列内容 'd'，占用 1 字节），每个变长字段的内容占用的字节数用 1 字节就可以表示（也就是 4、3、1 这 3 个数字可以分别用字节 0x04、0x03、0x01 表示）。但是，如果变长字段的内容占用的字节数比较多，可能就需要用 2 字节来表示。至于用 1 字节还是 2 字节来表示变长字段的真实数据占用的字节数，InnoDB 是有它的一套规则的。为了更好的表述清楚这个规则，我们引入 W、M 和 L 这几个符号，先分别看看这些符号的意思。</p>\n<pre><code>  - 假设某个字符集中最多需要W字节来表示一个字符（也就执行SHOW CHARSET语句后结果中的Maxlen列）。比如utf8mb4字符集中的W就是4，utf8是3，gbk是2，ascii是1\n  - 对于变长类型VARCHAR(M)来说，这种类型表示能存储最多M个字符（注意是字符不是字节哦），所以这种类型能表示的字符串最多占用的字节数就是 M*W\n  - 假设该变长字段实际存储的字符串占用的字节数是L\n</code></pre>\n<p>确定使用 1 字节还是 2 字节来表示一个变长字段的真实数据占用的字节数的规则就是这样：</p>\n<pre><code>  - 如果 M*W &lt;= 255，那么使用1字节来表示真实数据占用的字节数\n  - 如果 M*W &gt; 255，则分为下面两种情况：\n     - 如果 L &lt;= 127，则用1字节来表示真实数据占用的字节数\n     - 如果 L &gt; 127，则用2字节来表示真实数据占用的字节数\n</code></pre>\n<p>总结：如果该变长字段允许存储的最大字节数（M*W）超过 255 字节，并且真实数据占用的字节数（L）超过 127 字节，则使用 2 字节来表示真实数据占用的字节数，否则使用 1 字节。</p>\n<ol start=\"2\">\n<li>NULL 值列表</li>\n</ol>\n<p>一条记录中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中存储会很占地方，所以 COMPACT 行格式把一条记录中值为 NULL 的列统一管理起来，存储到 NULL 值列表中。处理过程如下：</p>\n<pre><code>  1. 统计表中允许存储NULL的列有哪些\n</code></pre>\n<p>主键列以及使用 NOT NULL 修饰的列都是不可以存储 NULL 值的，所以在统计的时候不会吧这些列算进去。比如表 record_format_demo 的 3 个列 c1、c3、c4 都允许存储 NULL 值，而 c2 列使用 NOT NULL 进行了修饰，不允许存储 NULL 值</p>\n<pre><code>  2. 如果表中没有允许存储NULL的列，则NULL值列表也就不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列。二进制位表示的意义如下：\n     1. 二进制位的值为1时，代表该列的值为 NULL\n     1. 二进制位的值为0时，代表该列的值不为 NULL\n</code></pre>\n<p>因为表 record_format_demo 有 3 个值允许为 NULL 的列，所以这 3 个列的二进制位的对应关系如下图所示。再次强调一次，二进制位按照列的顺序逆序排序，所以第一个列 c1 和最后一个二进制位对应<br />\n<img data-src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655022398588-408bbae8-2182-4e27-a997-0cbec694a0cd.jpeg\" alt=\"\" /></p>\n<ol start=\"3\">\n<li>MySQL 规定 NULL 值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，所以在字节的高位补 0，效果图如下</li>\n</ol>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655023378624-1c17e277-1c86-4c21-92c9-8f2847465606.jpeg\" alt=\"\" /><br />\n以此类推，如果一个表中有 9 个值允许为 NULL 的列，则这个记录的 NULL 值列表部分就需要 2 字节来表示了。<br />\n知道了规则以后，我们再返回头看看表 record_format_demo 中两条记录中的  NULL 值列表应该怎么存储。因为只有 c1、c3、c4 这 3 个列的值都允许存储 NULL 值，所以记录的 NULL 值列表处只需要一个字节</p>\n<pre><code>  - 对于第一条记录来说，c1、c3、c4这3个列的值都不为 NULL，所以它们对应的二进制位都是0，如下图所示\n</code></pre>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655025036533-5154c9d5-c725-4f38-b801-711c6d9d12d8.jpeg\" alt=\"\" /><br />\n所以第一条记录的 NULL 值列表用十六进制表示就是 0x00</p>\n<pre><code>  - 对于第二条记录来说，c1、c3、c4这3个列中c3和c4的值都为 NULL，所以这3个列对应的二进制位的情况如下图所示\n</code></pre>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655025036533-5154c9d5-c725-4f38-b801-711c6d9d12d8.jpeg\" alt=\"\" /><br />\n所以第二条记录的 NULL 值列表用十六进制表示就是 0x06<br />\n 这两条记录在填充了 NULL 值列表后的示意图如下所示：<br />\n<img data-src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655025577534-a5ec0d04-4fe2-4097-bbe8-f0593563dbe3.jpeg\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>记录头信息</li>\n</ol>\n<p>除了变长字段长度列表、NULL 值列表之外，还有一个称之为记录头信息的部分。记录头信息由固定的 5 字节组成，用于描述记录的一些属性。5 字节也就是 40 个二进制位，不同的位代表不同的意思，如下图所示：<br />\n<img data-src=\"https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1655045826404-a53de900-ffc0-41e6-9351-b63a46d1e7ea.jpeg\" alt=\"\" /><br />\n这些二进制位代表的详情信息如表所示：<br />\n<strong>记录头信息中各二进制位代表的详细信息</strong></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>大小（位）</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>预留位 1</td>\n<td>1</td>\n<td>没有使用</td>\n</tr>\n<tr>\n<td>预留位 2</td>\n<td>1</td>\n<td>没有使用</td>\n</tr>\n<tr>\n<td>deleted_flag</td>\n<td>1</td>\n<td>标记该记录是否被删除</td>\n</tr>\n<tr>\n<td>min_rec_flag</td>\n<td>1</td>\n<td>B + 树的每层非叶子节点中最小的项目项记录都会添加该标记</td>\n</tr>\n<tr>\n<td>n_owned</td>\n<td>4</td>\n<td>一个页面中的记录会被分成若干个组，每个组中有一个记录是 “带头大哥”，其余的记录都是 “小弟”。“带头大哥” 记录 n_owned  值都为 0</td>\n</tr>\n<tr>\n<td>heap_no</td>\n<td>13</td>\n<td>表示当前记录在页面堆中的相对位置</td>\n</tr>\n<tr>\n<td>record_type</td>\n<td>3</td>\n<td>表示当前记录的类型，0 表示普通记录，1 表示 B + 树飞叶子节点的目录项记录，2 表示 Infimum 记录，3 表示 Supremum 记录</td>\n</tr>\n<tr>\n<td>next_record</td>\n<td>16</td>\n<td>表示下一条记录的相对位置</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\">\n<li>记录的真实数据</li>\n</ol>\n<p>对于 record_format_demo 表来说，记录的真实数据除了 c1、c2、c3、c4 这几个我们自己定义的列的数据外，MySQL 会为每个记录默认地添加一些列（也称为隐藏列），具体的列如下表所示<br />\n<strong> MySQL 为每个记录默认添加的列</strong></p>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>是否必需</th>\n<th>占用空间</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>row_id</td>\n<td>否</td>\n<td>6 字节</td>\n<td>行 ID，唯一标识一条记录</td>\n</tr>\n<tr>\n<td>trx_id</td>\n<td>是</td>\n<td>6 字节</td>\n<td>事务 ID</td>\n</tr>\n<tr>\n<td>roll_pointer</td>\n<td>是</td>\n<td>7 字节</td>\n<td>回滚指针</td>\n</tr>\n</tbody>\n</table>\n<p>这里提一下 InnoDB 表的主键生成策略：优先使用用户自定义的主键作为主键；如果用户没有定义主键，则选取一个不允许存储 NULL 值的 UNIQUE 键作为主键：如果表中连不允许存储 NULL 值的 UNIQUE 键都没有定义，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键</p>\n<blockquote>\n<p>这几个真正的列的真正名称是 DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，但是后面的描述中都用小写描述</p>\n</blockquote>\n<ol start=\"3\">\n<li></li>\n</ol>\n<hr />\n<h2 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h2>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "https://fallingkids.github.io/mysql-note-02/",
            "url": "https://fallingkids.github.io/mysql-note-02/",
            "title": "一周浅谈：Mysql - 字符集和比较规则",
            "date_published": "2022-06-01T14:56:49.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>计算机中实际存储的是二进制数据，是没有办法直接存储字符串的，因此为了存储字符是建立在字符与二进制数据的映射关系之上。建立这个关系，我们首先需要解决两个问题：</p>\n<ul>\n<li>要把哪些字符映射成二进制数据？</li>\n<li>怎么映射？把字符映射成二进制数据叫做编码，将二进制数据映射到字符叫做解码</li>\n</ul>\n<pre><code>'a' -&gt; 00000001 (十六进制0x01)\n'b' -&gt; 00000010 (十六进制0x02)\n'A' -&gt; 00000011 (十六进制0x03)\n'B' -&gt; 00000100 (十六进制0x04)\n</code></pre>\n<p>现在有了我们自己的字符集，我们就可以用二进制表示一些字符串了，例如：</p>\n<ul>\n<li>'bA' -&gt; 0000001000000011 （十六进制 0x0203）</li>\n<li>'baB' -&gt; 000000100000000100000100 （十六进制 0x020104）</li>\n<li>'cd' -&gt; 无法表示，因为 huyizhou 字符集里不包含 'c' 和 'd'</li>\n</ul>\n<hr />\n<h2 id=\"字符比较规则\"><a class=\"anchor\" href=\"#字符比较规则\">#</a> 字符比较规则</h2>\n<p>其实字符的比较，最容易想到的就是比较两个字符对应的二进制编码大小。二进制比较规则景观很简单，但是有时候并不符合现实的需求。例如，在很多场景下，英文字符都是不区分大小写的，换句话说 'a' 和 'A' 是相等的，这个时候就不能简单的使用二进制比较，这个时候就需要这两个规则：</p>\n<ul>\n<li>将两个大小写不同的字符全部都转为大写或者小写</li>\n<li>再比较这两个字符对应的二进制数据</li>\n</ul>\n<hr />\n<h2 id=\"常见的字符集\"><a class=\"anchor\" href=\"#常见的字符集\">#</a> 常见的字符集</h2>\n<ul>\n<li>ASCII 字符集：共收录 128 个字符，包括空格、标点符号、数字、大小写字母和一些不可见的字符。由于 ASCII 字符集一共也才 128 个字符，所以可以使用一个字节来进行编码</li>\n</ul>\n<pre><code>'L' -&gt; 01001100 （十六进制0x4C，十进制76）\n'M' -&gt; 01001101 （十六进制0x4D，十进制77）\n</code></pre>\n<ul>\n<li>ISO 8859-1 字符集：共收录 256 个字符，在 ASCII 字符集的基础上又扩充了 128 个西欧常用字符，因此 ISO 8859-1 字符集也可以使用一个字节来进行编码</li>\n<li>GBK</li>\n<li>UTF-8</li>\n</ul>\n<h2 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h2>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "https://fallingkids.github.io/mysql-note-01/",
            "url": "https://fallingkids.github.io/mysql-note-01/",
            "title": "一周浅谈：Mysql整体架构设计",
            "date_published": "2022-06-01T02:50:55.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>最近刚开始再看《Mysql 是怎样运行的 -- 从根儿上理解 MySQL》，迫于见明的压力，在此开始写一些笔记也好或者对于该书获取的一些知识点提炼出来</p>\n<hr />\n<h2 id=\"架构图\"><a class=\"anchor\" href=\"#架构图\">#</a> 架构图</h2>\n<p><img data-src=\"https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654054743/blog/2022-06-01/image_qvugqu.png\" alt=\"image.png\" /></p>\n<ol>\n<li>建立连接</li>\n</ol>\n<p>就跟大部分的开源组件的模式一样，client 和 server。client 具体为 api，在不同的应用方进行调用；server 具体实现业务如存储，查询，分词等一些逻辑。当然，client 与 server 之间的连接是有通过我们熟悉的 tcp 连接，还有命名管道和共享内存，UNIX 域套接字</p>\n<ol start=\"2\">\n<li>解析与优化</li>\n</ol>\n<p>mysql 服务器从客户端那获得了文本形式的请求，接下来数据要从存储中取出来，还需要很多前置的过程，比如：要取什么数据（对于 sql 语句需要做出分析传递给下一层），怎么取是最快，这部分做这件事情</p>\n<ol start=\"3\">\n<li>存储引擎</li>\n</ol>\n<p>当服务完成了查询优化以后，都还没有真正地去访问真实的表中数据（在查询期间可能会访问表中少量的数据）。因此，mysql 服务器把数据的存储和提取操作都封装到存储引擎模块（表处理器）中。从逻辑上，表示一行一行的记录组成。在物理上，如何表示记录，怎么读取记录，把数据写入具体的物理存储器，这些都存储引擎负责的事情。同时存储引擎是各种各样的，可以根据用户自己选择去使用，因此作为开发者的我们可以自己开发一套存储引擎去使用</p>\n<hr />\n<h2 id=\"建立连接\"><a class=\"anchor\" href=\"#建立连接\">#</a> 建立连接</h2>\n<ol>\n<li>TCP/IP</li>\n</ol>\n<p>在真实的环境中，数据库服务器进程和客户端进程可能会运行在不同的主机中，因此必须网络进行通讯。mysql 服务器中默认的端口号是 3306，默认监听 3306 端口。因此我们就可以通过 IP 地址 + 端口号的方式与这个进程建立连接，这样进程间就可以进行网络通讯。下面一些关于网络连接用到的指令</p>\n<pre><code>mysqld -P3307\n</code></pre>\n<pre><code>mysql -h127.0.0.1 -uroot -P3307 -p\n</code></pre>\n<ol start=\"2\">\n<li>命名管道和共享内存</li>\n</ol>\n<p>windows 用户可以用这招，我就不细了解</p>\n<ol start=\"3\">\n<li>UNIX 域套接字</li>\n</ol>\n<p>服务器进程和客户端进程都运行在操作系统为类 UNIX 的同一台机器上，就可以使用这个方法进行进程间通讯。不细聊了</p>\n<hr />\n<h2 id=\"连接管理\"><a class=\"anchor\" href=\"#连接管理\">#</a> 连接管理</h2>\n<ul>\n<li>线程池</li>\n</ul>\n<p>当每有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程专门处理这个客户端的交互：当该客户端退出时会与服务器断开连接，服务器并不会直接把和客户端交互建立起来的线程销毁，而是把他缓存起来，当另一个新的客户端再进行连接时，把这个缓存的线程分配给新客户端。这样就避免了频繁创建和销毁线程，节省开销。mysql 服务器是为每一个进来的客户端分配一个线程，这样的问题就会有，加入线程分配的太多就会严重影响系统性能，所以我们也需要限制可以同时连接到服务器的客户端数量，也就是我们日常口中经常提到的连接池，mysql 也把这个字段开放出来，让我们来配置，因此这个配置的数值很考验开发者对我们的机器资源以及需要什么样的性能要有一个很深刻的理解。</p>\n<ul>\n<li>身份认证</li>\n</ul>\n<p>当客户端发起连接时，是会携带主机信息、用户名、密码等信息，服务器程序就会对客户端提供的这些信息进行认证。如果认证失败，服务器就会拒绝连接。同时，当客户端与服务器是部署在不同的地方，可以采用传输层安全性协议对连接进行加密</p>\n<h2 id=\"解析与优化\"><a class=\"anchor\" href=\"#解析与优化\">#</a> 解析与优化</h2>\n<ol>\n<li>查询缓存（5.7.20 以后不推荐使用，8.0 中直接将其删除）</li>\n</ol>\n<p>我在平时开发的过程中，当缓存中没有数据时，一次数据获取都从调用 BI 的数据接口来获取。但是为了提高效率，会把刚刚查询的结果放入缓存中，这样在短时间内再查询一次就能提高查询的效率，不需要做过多的计算。mysql 也是如此，但是 mysql 对于两个查询请求有任何字符上面的不同（例如，空格、注释、大小写），都会导致缓存不会命中。另外，查询中包含某些函数、用户自定义变量和函数、系统表，如 mysql、information_schema、performance_schema 数据库中的表，这个请求也不会命中。当然，缓存也会有缓存失效的时候，只要表的结构或者发生了更改或者数据发生了修改，对应的所有缓存表全部失效</p>\n<ol start=\"2\">\n<li>语法解析</li>\n</ol>\n<p>我们知道客户端程序发送过来的请求指示一段文本，mysql 服务器首先要对这段文本进行分析。属于编译过程了，设计词法解析、语法解析、语义分析，不深聊了</p>\n<ol start=\"3\">\n<li>\n<p>查询优化</p>\n<p>语法解析之后，服务器已经获得了需要的信息（要查询的表和列是哪些、搜索条件是什么）。但是我们写的 mysql 语句执行起来效率可能并不是那么高，所以 mysql 的优化程序会对我们的语句做一些优化，优化结果就是生成一个执行计划（explain），这个执行计划表明了应该用哪些索引执行查询，以及表之间额查询顺序是啥，等等。</p>\n</li>\n</ol>\n<hr />\n<h2 id=\"存储引擎\"><a class=\"anchor\" href=\"#存储引擎\">#</a> 存储引擎</h2>\n<p>mysql 服务器把数据的存储和提取操作都封装到了一个名为存储引擎的模块中，mysql 中有很多存储引擎，但是最常用的还是 InnoDB，偶尔用一下 MyISAM，再偶尔用一下 MEMORY</p>\n<ul>\n<li>InnoDB</li>\n</ul>\n<p>支持事务、行级别、外键</p>\n<ul>\n<li>MyISAM</li>\n</ul>\n<p>主要的非事务处理存储引擎</p>\n<ul>\n<li>MEMORY</li>\n</ul>\n<p>数据只存储在内存，不存储在磁盘；多用于临时表</p>\n<hr />\n<h2 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h2>\n<p>本来想写第二章的内容，启动选项和系统变量，但是发现感觉不是很有必要，后面有必要再补上</p>\n",
            "tags": [
                "Mysql"
            ]
        },
        {
            "id": "https://fallingkids.github.io/hello-world/",
            "url": "https://fallingkids.github.io/hello-world/",
            "title": "Hello World",
            "date_published": "2022-05-31T07:28:50.131Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}