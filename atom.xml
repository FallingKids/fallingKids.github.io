<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fallingkids.github.io</id>
    <title>技术笔记</title>
    <subtitle>幸好有你雯</subtitle>
    <icon>https://fallingkids.github.io/images/favicon.ico</icon>
    <link href="https://fallingkids.github.io" />
    <author>
      <name>彼得仔</name>
    </author>
    <updated>2022-06-05T14:51:18.000Z</updated>
    <category term="node.js" />
    <category term="golang" />
    <category term="mysql" />
    <category term="linux" />
    <entry>
        <id>https://fallingkids.github.io/mysql-note-03/</id>
        <title>一周浅谈：InnoDB记录存储结构</title>
        <link rel="alternate" href="https://fallingkids.github.io/mysql-note-03/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;之前的文章，mysql 对于我们来说还只是一个 “黑盒”，我们只负责使用客户端发送请求，并且等待服务器返回结果。但是我们现在需要去搞清楚三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表中的数据存到哪里（where）&lt;/li&gt;
&lt;li&gt;存放格式（what）&lt;/li&gt;
&lt;li&gt;mysql 以书面方式来访问数据（how）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，我就重点总结一下 mysql 默认的存储引擎 InnoDB，其他存储引擎的设计思路也大差不差，只不过特性不同罢了，设计思路差不多&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;innodb页简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#innodb页简介&#34;&gt;#&lt;/a&gt; InnoDB 页简介&lt;/h2&gt;
&lt;p&gt;InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，即使我们关闭并且重启服务器，数据还是存在的。而真正处理数据的过程发生在内存中，所以是要把磁盘中的数据加载到内存中。如果是处理写入或修改请求，就还需要把内存中的内容刷新到磁盘上。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;innodb行格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#innodb行格式&#34;&gt;#&lt;/a&gt; InnoDB 行格式&lt;/h2&gt;
&lt;p&gt;我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘中的&lt;strong&gt;存放形式&lt;/strong&gt;也被称为&lt;strong&gt;行格式或者记录格式&lt;/strong&gt;。InnoDB 的设计者设计了 4 中不同类型的行格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COMPACT&lt;/li&gt;
&lt;li&gt;REDUNDANT&lt;/li&gt;
&lt;li&gt;DYNAMIC&lt;/li&gt;
&lt;li&gt;COMPRESSED&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指定行格式的语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指定行格式的语法&#34;&gt;#&lt;/a&gt; 指定行格式的语法&lt;/h3&gt;
&lt;p&gt;可以在&lt;strong&gt;创建&lt;/strong&gt;或者&lt;strong&gt;修改&lt;/strong&gt;表的语句中指定记录所使用的的行格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE 表名 （列的信息） ROW_FORMAT=行格式名称;
ALTER TABLE 表名 ROW_FORMAT=行格式名称;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了探究接下来各个行格式下的数据结构到底有啥不同，所以假设在 test_db 中创建一张表 record_format_demo，同时指定它的行格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; CREATE TABLE record_format_demo (
    -&amp;gt;     c1 VARCHAR(10),
    -&amp;gt;		 c2 VARCHAR(10) NOT NULL,
    -&amp;gt;		 c3 CHAR(10),
    -&amp;gt;     c4 VARCHAR(10),
    -&amp;gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;
    Query OK, 0 rows affected (0. 03 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这张表的行格式是 COMPACT，林外，我们还显式指定了字符集为 ascii（因为 ascii 字符集只包含空格、标点符号、数字、大小写字母和一些不可见字符，所以汉字不能存到这张表中）现在我向表中插入两条记录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES (&#39;aaaa&#39;, &#39;bbb&#39;, &#39;cc&#39;, &#39;d&#39;), (&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);
Query ok, 2 rows affected (0.02 sec)
Records: 2 Duplicates: 0 Warnings: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在表中的记录是这个样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可以看看每个行格式下的存储结构到底有啥不同&lt;/p&gt;
&lt;h3 id=&#34;compact行格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#compact行格式&#34;&gt;#&lt;/a&gt; COMPACT 行格式&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654441308/blog/2022-06-05/mysql-not-03-img1_lzdbrr.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
COMPACT 行格式示意图&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;记录的额外信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这部分信息是服务器为了更好地管理记录而不得不额外添加的一些信息。这些额外信息分为 3 个部分，分别是变长字段长度列表、NULL 值列表和记录头信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变长字段长度列表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mysql 支持一些变长的数据类型，比如 VARCHAR (M)、VARBINARY (M)、各种 TEXT 类型、各种 BLOB 类型。这些数据类型的列称为变长字段。因为变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于吧 mysql 服务器高懵逼，所以总结来说这些变长字段占用的存储空间分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;真正的数据内容&lt;/li&gt;
&lt;li&gt;该数据占用的字节数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 COMPACT 行格式中，所有变长字段的真实数据占用的字节数都存放在记录的开头位置，从而形成一个变长字段长度列表，各边长字段的真实数据占用的字节数按照列的顺序&lt;strong&gt;逆序&lt;/strong&gt;存放。&lt;br /&gt;
以 record_format_demo 表中第一条记录来举个例子，因为 record_format_demo 表中的 c1、c2、c4 列都是 VARCHAR (10) 类型的，也就是变长的数据类型所以，所以这 3 个列的值占用的存储空间按字节数都需要保存在记录开头处。看下第一条记录各变长字段内容的长度&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;存储内容&lt;/th&gt;
&lt;th&gt;内容长度（十进制表示）&lt;/th&gt;
&lt;th&gt;内容长度（十六进制表示）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c1&lt;/td&gt;
&lt;td&gt;&#39;aaaa&#39;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0x04&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c2&lt;/td&gt;
&lt;td&gt;&#39;bbb&#39;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0x03&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c4&lt;/td&gt;
&lt;td&gt;&#39;d&#39;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为这些长度值需要按照列的顺序逆序存放，所以最后变长字段长度列表的字节串用十六进制的表示的效果就是：&lt;br /&gt;
01 03 04&lt;br /&gt;
 需要说明的是，这里各个字节之间实际上没有空格，只是为了更好理解罢了。&lt;br /&gt;
把这个字节串组成的变长字段长度列表填入到&lt;strong&gt; COMPACT 行格式示意图&lt;/strong&gt;的效果如下图所示。&lt;br /&gt;
&lt;img data-src=&#34;https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654441308/blog/2022-06-05/mysql-note-03-img2_rpi0ux.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
第一条记录的存储格式&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录的真实数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;其他&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他&#34;&gt;#&lt;/a&gt; 其他&lt;/h2&gt;
</content>
        <category term="Mysql" scheme="https://fallingkids.github.io/tags/Mysql/" />
        <updated>2022-06-05T14:51:18.000Z</updated>
    </entry>
    <entry>
        <id>https://fallingkids.github.io/%E4%B8%80%E5%91%A8%E6%B5%85%E8%B0%88%EF%BC%9AInnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</id>
        <title></title>
        <link rel="alternate" href="https://fallingkids.github.io/%E4%B8%80%E5%91%A8%E6%B5%85%E8%B0%88%EF%BC%9AInnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;之前的文章，mysql 对于我们来说还只是一个 “黑盒”，我们只负责使用客户端发送请求，并且等待服务器返回结果。但是我们现在需要去搞清楚三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表中的数据存到哪里（where）&lt;/li&gt;
&lt;li&gt;存放格式（what）&lt;/li&gt;
&lt;li&gt;mysql 以书面方式来访问数据（how）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，我就重点总结一下 mysql 默认的存储引擎 InnoDB，其他存储引擎的设计思路也大差不差，只不过特性不同罢了，设计思路差不多&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;innodb页简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#innodb页简介&#34;&gt;#&lt;/a&gt; InnoDB 页简介&lt;/h2&gt;
&lt;p&gt;InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，即使我们关闭并且重启服务器，数据还是存在的。而真正处理数据的过程发生在内存中，所以是要把磁盘中的数据加载到内存中。如果是处理写入或修改请求，就还需要把内存中的内容刷新到磁盘上。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;innodb行格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#innodb行格式&#34;&gt;#&lt;/a&gt; InnoDB 行格式&lt;/h2&gt;
&lt;p&gt;我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘中的&lt;strong&gt;存放形式&lt;/strong&gt;也被称为&lt;strong&gt;行格式或者记录格式&lt;/strong&gt;。InnoDB 的设计者设计了 4 中不同类型的行格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COMPACT&lt;/li&gt;
&lt;li&gt;REDUNDANT&lt;/li&gt;
&lt;li&gt;DYNAMIC&lt;/li&gt;
&lt;li&gt;COMPRESSED&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指定行格式的语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指定行格式的语法&#34;&gt;#&lt;/a&gt; 指定行格式的语法&lt;/h3&gt;
&lt;p&gt;可以在&lt;strong&gt;创建&lt;/strong&gt;或者&lt;strong&gt;修改&lt;/strong&gt;表的语句中指定记录所使用的的行格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE 表名 （列的信息） ROW_FORMAT=行格式名称;
ALTER TABLE 表名 ROW_FORMAT=行格式名称;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了探究接下来各个行格式下的数据结构到底有啥不同，所以假设在 test_db 中创建一张表 record_format_demo，同时指定它的行格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; CREATE TABLE record_format_demo (
    -&amp;gt;     c1 VARCHAR(10),
    -&amp;gt;		 c2 VARCHAR(10) NOT NULL,
    -&amp;gt;		 c3 CHAR(10),
    -&amp;gt;     c4 VARCHAR(10),
    -&amp;gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;
    Query OK, 0 rows affected (0. 03 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这张表的行格式是 COMPACT，林外，我们还显式指定了字符集为 ascii（因为 ascii 字符集只包含空格、标点符号、数字、大小写字母和一些不可见字符，所以汉字不能存到这张表中）现在我向表中插入两条记录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES (&#39;aaaa&#39;, &#39;bbb&#39;, &#39;cc&#39;, &#39;d&#39;), (&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);
Query ok, 2 rows affected (0.02 sec)
Records: 2 Duplicates: 0 Warnings: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在表中的记录是这个样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可以看看每个行格式下的存储结构到底有啥不同&lt;/p&gt;
&lt;h3 id=&#34;compact行格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#compact行格式&#34;&gt;#&lt;/a&gt; COMPACT 行格式&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1654414563605-d21d3ee3-1534-4408-b536-9514269e7f2f.jpeg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
COMPACT 行格式示意图&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;记录的额外信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这部分信息是服务器为了更好地管理记录而不得不额外添加的一些信息。这些额外信息分为 3 个部分，分别是变长字段长度列表、NULL 值列表和记录头信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变长字段长度列表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mysql 支持一些变长的数据类型，比如 VARCHAR (M)、VARBINARY (M)、各种 TEXT 类型、各种 BLOB 类型。这些数据类型的列称为变长字段。因为变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于吧 mysql 服务器高懵逼，所以总结来说这些变长字段占用的存储空间分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;真正的数据内容&lt;/li&gt;
&lt;li&gt;该数据占用的字节数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 COMPACT 行格式中，所有变长字段的真实数据占用的字节数都存放在记录的开头位置，从而形成一个变长字段长度列表，各边长字段的真实数据占用的字节数按照列的顺序&lt;strong&gt;逆序&lt;/strong&gt;存放。&lt;br /&gt;
以 record_format_demo 表中第一条记录来举个例子，因为 record_format_demo 表中的 c1、c2、c4 列都是 VARCHAR (10) 类型的，也就是变长的数据类型所以，所以这 3 个列的值占用的存储空间按字节数都需要保存在记录开头处。看下第一条记录各变长字段内容的长度&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;存储内容&lt;/th&gt;
&lt;th&gt;内容长度（十进制表示）&lt;/th&gt;
&lt;th&gt;内容长度（十六进制表示）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c1&lt;/td&gt;
&lt;td&gt;&#39;aaaa&#39;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0x04&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c2&lt;/td&gt;
&lt;td&gt;&#39;bbb&#39;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0x03&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c4&lt;/td&gt;
&lt;td&gt;&#39;d&#39;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为这些长度值需要按照列的顺序逆序存放，所以最后变长字段长度列表的字节串用十六进制的表示的效果就是：&lt;br /&gt;
01 03 04&lt;br /&gt;
 需要说明的是，这里各个字节之间实际上没有空格，只是为了更好理解罢了。&lt;br /&gt;
把这个字节串组成的变长字段长度列表填入到&lt;strong&gt; COMPACT 行格式示意图&lt;/strong&gt;的效果如下图所示。&lt;br /&gt;
&lt;img data-src=&#34;https://cdn.nlark.com/yuque/0/2022/jpeg/2349795/1654440133176-42270066-4100-4279-b5d7-a42293d33e2d.jpeg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
第一条记录的存储格式&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录的真实数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;其他&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他&#34;&gt;#&lt;/a&gt; 其他&lt;/h2&gt;
</content>
        <updated>2022-06-05T14:50:55.246Z</updated>
    </entry>
    <entry>
        <id>https://fallingkids.github.io/mysql-note-02/</id>
        <title>一周浅谈：Mysql - 字符集和比较规则</title>
        <link rel="alternate" href="https://fallingkids.github.io/mysql-note-02/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;计算机中实际存储的是二进制数据，是没有办法直接存储字符串的，因此为了存储字符是建立在字符与二进制数据的映射关系之上。建立这个关系，我们首先需要解决两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要把哪些字符映射成二进制数据？&lt;/li&gt;
&lt;li&gt;怎么映射？把字符映射成二进制数据叫做编码，将二进制数据映射到字符叫做解码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;a&#39; -&amp;gt; 00000001 (十六进制0x01)
&#39;b&#39; -&amp;gt; 00000010 (十六进制0x02)
&#39;A&#39; -&amp;gt; 00000011 (十六进制0x03)
&#39;B&#39; -&amp;gt; 00000100 (十六进制0x04)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在有了我们自己的字符集，我们就可以用二进制表示一些字符串了，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&#39;bA&#39; -&amp;gt; 0000001000000011 （十六进制 0x0203）&lt;/li&gt;
&lt;li&gt;&#39;baB&#39; -&amp;gt; 000000100000000100000100 （十六进制 0x020104）&lt;/li&gt;
&lt;li&gt;&#39;cd&#39; -&amp;gt; 无法表示，因为 huyizhou 字符集里不包含 &#39;c&#39; 和 &#39;d&#39;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;字符比较规则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#字符比较规则&#34;&gt;#&lt;/a&gt; 字符比较规则&lt;/h2&gt;
&lt;p&gt;其实字符的比较，最容易想到的就是比较两个字符对应的二进制编码大小。二进制比较规则景观很简单，但是有时候并不符合现实的需求。例如，在很多场景下，英文字符都是不区分大小写的，换句话说 &#39;a&#39; 和 &#39;A&#39; 是相等的，这个时候就不能简单的使用二进制比较，这个时候就需要这两个规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将两个大小写不同的字符全部都转为大写或者小写&lt;/li&gt;
&lt;li&gt;再比较这两个字符对应的二进制数据&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;常见的字符集&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常见的字符集&#34;&gt;#&lt;/a&gt; 常见的字符集&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ASCII 字符集：共收录 128 个字符，包括空格、标点符号、数字、大小写字母和一些不可见的字符。由于 ASCII 字符集一共也才 128 个字符，所以可以使用一个字节来进行编码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;L&#39; -&amp;gt; 01001100 （十六进制0x4C，十进制76）
&#39;M&#39; -&amp;gt; 01001101 （十六进制0x4D，十进制77）
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;ISO 8859-1 字符集：共收录 256 个字符，在 ASCII 字符集的基础上又扩充了 128 个西欧常用字符，因此 ISO 8859-1 字符集也可以使用一个字节来进行编码&lt;/li&gt;
&lt;li&gt;GBK&lt;/li&gt;
&lt;li&gt;UTF-8&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他&#34;&gt;#&lt;/a&gt; 其他&lt;/h2&gt;
</content>
        <category term="Mysql" scheme="https://fallingkids.github.io/tags/Mysql/" />
        <updated>2022-06-01T14:56:49.000Z</updated>
    </entry>
    <entry>
        <id>https://fallingkids.github.io/mysql-note-01/</id>
        <title>一周浅谈：Mysql整体架构设计</title>
        <link rel="alternate" href="https://fallingkids.github.io/mysql-note-01/"/>
        <content type="html">&lt;h2 id=&#34;前言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#前言&#34;&gt;#&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;最近刚开始再看《Mysql 是怎样运行的 -- 从根儿上理解 MySQL》，迫于见明的压力，在此开始写一些笔记也好或者对于该书获取的一些知识点提炼出来&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;架构图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#架构图&#34;&gt;#&lt;/a&gt; 架构图&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://res.cloudinary.com/https-fallingkids-github-io/image/upload/v1654054743/blog/2022-06-01/image_qvugqu.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就跟大部分的开源组件的模式一样，client 和 server。client 具体为 api，在不同的应用方进行调用；server 具体实现业务如存储，查询，分词等一些逻辑。当然，client 与 server 之间的连接是有通过我们熟悉的 tcp 连接，还有命名管道和共享内存，UNIX 域套接字&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;解析与优化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mysql 服务器从客户端那获得了文本形式的请求，接下来数据要从存储中取出来，还需要很多前置的过程，比如：要取什么数据（对于 sql 语句需要做出分析传递给下一层），怎么取是最快，这部分做这件事情&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;存储引擎&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当服务完成了查询优化以后，都还没有真正地去访问真实的表中数据（在查询期间可能会访问表中少量的数据）。因此，mysql 服务器把数据的存储和提取操作都封装到存储引擎模块（表处理器）中。从逻辑上，表示一行一行的记录组成。在物理上，如何表示记录，怎么读取记录，把数据写入具体的物理存储器，这些都存储引擎负责的事情。同时存储引擎是各种各样的，可以根据用户自己选择去使用，因此作为开发者的我们可以自己开发一套存储引擎去使用&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;建立连接&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#建立连接&#34;&gt;#&lt;/a&gt; 建立连接&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;TCP/IP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在真实的环境中，数据库服务器进程和客户端进程可能会运行在不同的主机中，因此必须网络进行通讯。mysql 服务器中默认的端口号是 3306，默认监听 3306 端口。因此我们就可以通过 IP 地址 + 端口号的方式与这个进程建立连接，这样进程间就可以进行网络通讯。下面一些关于网络连接用到的指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysqld -P3307
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mysql -h127.0.0.1 -uroot -P3307 -p
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;命名管道和共享内存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;windows 用户可以用这招，我就不细了解&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;UNIX 域套接字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务器进程和客户端进程都运行在操作系统为类 UNIX 的同一台机器上，就可以使用这个方法进行进程间通讯。不细聊了&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;连接管理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#连接管理&#34;&gt;#&lt;/a&gt; 连接管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;线程池&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当每有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程专门处理这个客户端的交互：当该客户端退出时会与服务器断开连接，服务器并不会直接把和客户端交互建立起来的线程销毁，而是把他缓存起来，当另一个新的客户端再进行连接时，把这个缓存的线程分配给新客户端。这样就避免了频繁创建和销毁线程，节省开销。mysql 服务器是为每一个进来的客户端分配一个线程，这样的问题就会有，加入线程分配的太多就会严重影响系统性能，所以我们也需要限制可以同时连接到服务器的客户端数量，也就是我们日常口中经常提到的连接池，mysql 也把这个字段开放出来，让我们来配置，因此这个配置的数值很考验开发者对我们的机器资源以及需要什么样的性能要有一个很深刻的理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;身份认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当客户端发起连接时，是会携带主机信息、用户名、密码等信息，服务器程序就会对客户端提供的这些信息进行认证。如果认证失败，服务器就会拒绝连接。同时，当客户端与服务器是部署在不同的地方，可以采用传输层安全性协议对连接进行加密&lt;/p&gt;
&lt;h2 id=&#34;解析与优化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#解析与优化&#34;&gt;#&lt;/a&gt; 解析与优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;查询缓存（5.7.20 以后不推荐使用，8.0 中直接将其删除）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我在平时开发的过程中，当缓存中没有数据时，一次数据获取都从调用 BI 的数据接口来获取。但是为了提高效率，会把刚刚查询的结果放入缓存中，这样在短时间内再查询一次就能提高查询的效率，不需要做过多的计算。mysql 也是如此，但是 mysql 对于两个查询请求有任何字符上面的不同（例如，空格、注释、大小写），都会导致缓存不会命中。另外，查询中包含某些函数、用户自定义变量和函数、系统表，如 mysql、information_schema、performance_schema 数据库中的表，这个请求也不会命中。当然，缓存也会有缓存失效的时候，只要表的结构或者发生了更改或者数据发生了修改，对应的所有缓存表全部失效&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;语法解析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们知道客户端程序发送过来的请求指示一段文本，mysql 服务器首先要对这段文本进行分析。属于编译过程了，设计词法解析、语法解析、语义分析，不深聊了&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;查询优化&lt;/p&gt;
&lt;p&gt;语法解析之后，服务器已经获得了需要的信息（要查询的表和列是哪些、搜索条件是什么）。但是我们写的 mysql 语句执行起来效率可能并不是那么高，所以 mysql 的优化程序会对我们的语句做一些优化，优化结果就是生成一个执行计划（explain），这个执行计划表明了应该用哪些索引执行查询，以及表之间额查询顺序是啥，等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;存储引擎&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#存储引擎&#34;&gt;#&lt;/a&gt; 存储引擎&lt;/h2&gt;
&lt;p&gt;mysql 服务器把数据的存储和提取操作都封装到了一个名为存储引擎的模块中，mysql 中有很多存储引擎，但是最常用的还是 InnoDB，偶尔用一下 MyISAM，再偶尔用一下 MEMORY&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持事务、行级别、外键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要的非事务处理存储引擎&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MEMORY&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据只存储在内存，不存储在磁盘；多用于临时表&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;其他&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他&#34;&gt;#&lt;/a&gt; 其他&lt;/h2&gt;
&lt;p&gt;本来想写第二章的内容，启动选项和系统变量，但是发现感觉不是很有必要，后面有必要再补上&lt;/p&gt;
</content>
        <category term="Mysql" scheme="https://fallingkids.github.io/tags/Mysql/" />
        <updated>2022-06-01T02:50:55.000Z</updated>
    </entry>
    <entry>
        <id>https://fallingkids.github.io/hello-world/</id>
        <title>Hello World</title>
        <link rel="alternate" href="https://fallingkids.github.io/hello-world/"/>
        <content type="html">&lt;p&gt;Welcome to &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvLw==&#34;&gt;Hexo&lt;/span&gt;! This is your very first post. Check &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv&#34;&gt;documentation&lt;/span&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=&#34;&gt;troubleshooting&lt;/span&gt; or you can ask me on &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==&#34;&gt;GitHub&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id=&#34;quick-start&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#quick-start&#34;&gt;#&lt;/a&gt; Quick Start&lt;/h2&gt;
&lt;h3 id=&#34;create-a-new-post&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#create-a-new-post&#34;&gt;#&lt;/a&gt; Create a new post&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo new &lt;span class=&#34;token string&#34;&gt;&#34;My New Post&#34;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s&#34;&gt;Writing&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;run-server&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#run-server&#34;&gt;#&lt;/a&gt; Run server&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo server&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=&#34;&gt;Server&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;generate-static-files&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#generate-static-files&#34;&gt;#&lt;/a&gt; Generate static files&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo generate&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s&#34;&gt;Generating&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;deploy-to-remote-sites&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deploy-to-remote-sites&#34;&gt;#&lt;/a&gt; Deploy to remote sites&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo deploy&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s&#34;&gt;Deployment&lt;/span&gt;&lt;/p&gt;
</content>
        <updated>2022-05-31T07:28:50.131Z</updated>
    </entry>
</feed>
